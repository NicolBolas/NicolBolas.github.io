<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Unofficial OpenGL Software Development Kit: Mesh Generators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unofficial OpenGL Software Development Kit
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mesh Generators<div class="ingroups"><a class="el" href="group__module__glmesh__mesh.html">Static Mesh</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>These functions generate <a class="el" href="classglmesh_1_1_mesh.html" title="An object that represents a static collection of mesh data.">glmesh::Mesh</a> objects. These are simple functions for making reuseable mesh objects. The meshes generated may not be optimally ordered for maximum throughput.</p>
<p>The meshes generated by the mesh generator functions will assume at least OpenGL 3.2 is available. As such, they will use core 3.2 functionality, such as primitive restart, <code>glDrawElementsBaseVertex</code> and the like.</p>
<p>All generated meshes use the OpenGL default for their face orientation. Namely, counter-clockwise is front. Some meshes will have options to generate two-sided objects, if you so desire.</p>
<p>The attribute indices used by the mesh generator functions are standardized. They are as follows:</p>
<ul>
<li>0: Position (three-dimensional, float) </li>
<li>1: Color, diffuse (four-dimensional, float) </li>
<li>2: Normal (three-dimensional, float) </li>
<li>3: Tangent, for establishing an NBT basis (three-dimensional, float) </li>
<li>4: Bitangent, for establishing an NBT basis (three-dimensional, float) </li>
<li>5: Texture coordinate (two-dimensional, float)</li>
</ul>
<p>The main VAO of each mesh includes all attributes. There will be variants generated containing fewer attributes. The naming convention for generated mesh variants is as follows:</p>
<ul>
<li><code>unlit</code> or <code>flat</code>: Position </li>
<li><code>lit</code>: Position+Normal </li>
<li><code>tex</code>: Position+TexCoord </li>
<li><code>color</code>: Position+Color</li>
</ul>
<p>These can be combined with <code>-</code> characters (except for <code>unlit</code>). So <code>lit-tex</code> means positions, normals, and texture coordinates. The order doesn't matter, so <code>lit-tex</code> is the same as <code>tex-lit</code>.</p>
<p>Some generator functions allow the user to provide a glmesh::gen::ColorArray, defining a sequence of colors. These colors will be applied to the vertices or faces of the object, depending on the generator. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2930a467ffc520ce9e4e82e8fcc9712e"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga2930a467ffc520ce9e4e82e8fcc9712e">glmesh::gen::FullScreenQuad</a> ()</td></tr>
<tr class="memdesc:ga2930a467ffc520ce9e4e82e8fcc9712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh of a full-screen quad. Useful for post-processing effects.  <a href="#ga2930a467ffc520ce9e4e82e8fcc9712e">More...</a><br/></td></tr>
<tr class="separator:ga2930a467ffc520ce9e4e82e8fcc9712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99cf6f0f84aba3c82900c5f20efc1b0"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#gaf99cf6f0f84aba3c82900c5f20efc1b0">glmesh::gen::GroundPlane</a> (int numXVerts, int numYVerts, bool bDoubleSided=true)</td></tr>
<tr class="memdesc:gaf99cf6f0f84aba3c82900c5f20efc1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh ground plane. Can be double-sided and arbitrarily tessellated.  <a href="#gaf99cf6f0f84aba3c82900c5f20efc1b0">More...</a><br/></td></tr>
<tr class="separator:gaf99cf6f0f84aba3c82900c5f20efc1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Structures</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2dec5ee9db863ffb68915b70bce4efe4"></a>These generators build larger, complex structures out of smaller functional units. These shapes are useful for showing off lighting and other effects. These functions are parameterized, allowing them to produce structures of arbitrary (within reason) sizes. </p>
</td></tr>
<tr class="memitem:gab0e2e9c342f7d20f172746488b492fad"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#gab0e2e9c342f7d20f172746488b492fad">glmesh::gen::CubeBlock</a> (int numCubesOnEdge, const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:gab0e2e9c342f7d20f172746488b492fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cubical block of cubes in an alternating pattern.  <a href="#gab0e2e9c342f7d20f172746488b492fad">More...</a><br/></td></tr>
<tr class="separator:gab0e2e9c342f7d20f172746488b492fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e3ef4891fa22062886d18c22ac1489"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga08e3ef4891fa22062886d18c22ac1489">glmesh::gen::CubePyramid</a> (int numCubesTall, const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:ga08e3ef4891fa22062886d18c22ac1489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pyramid made of cubes, in an alternating pattern.  <a href="#ga08e3ef4891fa22062886d18c22ac1489">More...</a><br/></td></tr>
<tr class="separator:ga08e3ef4891fa22062886d18c22ac1489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Platonic Solids</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe471010627f50ac3f2aef31c59d4b002"></a>These functions generate meshes for the 5 Platonic solids. All of them take an optional list of colors to be applied to faces. All of them provide face normals, since they are all faceted. </p>
</td></tr>
<tr class="memitem:ga2a1ee94134474b911c2939d6840c1c3b"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga2a1ee94134474b911c2939d6840c1c3b">glmesh::gen::Tetrahedron</a> (const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:ga2a1ee94134474b911c2939d6840c1c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a regular, unit tetrahedron.  <a href="#ga2a1ee94134474b911c2939d6840c1c3b">More...</a><br/></td></tr>
<tr class="separator:ga2a1ee94134474b911c2939d6840c1c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5513a56bfc83bca63125e933227cfcd5"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga5513a56bfc83bca63125e933227cfcd5">glmesh::gen::Cube</a> (const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:ga5513a56bfc83bca63125e933227cfcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a unit cube.  <a href="#ga5513a56bfc83bca63125e933227cfcd5">More...</a><br/></td></tr>
<tr class="separator:ga5513a56bfc83bca63125e933227cfcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2347c82475d03c07a3ff286f1ce22bfa"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga2347c82475d03c07a3ff286f1ce22bfa">glmesh::gen::Octahedron</a> (const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:ga2347c82475d03c07a3ff286f1ce22bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a regular, unit octahedron.  <a href="#ga2347c82475d03c07a3ff286f1ce22bfa">More...</a><br/></td></tr>
<tr class="separator:ga2347c82475d03c07a3ff286f1ce22bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d7a7e06600872fb96e40ef31d2af90"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#gaa3d7a7e06600872fb96e40ef31d2af90">glmesh::gen::Dodecahedron</a> (const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:gaa3d7a7e06600872fb96e40ef31d2af90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a regular, (nearly) unit dodecahedron.  <a href="#gaa3d7a7e06600872fb96e40ef31d2af90">More...</a><br/></td></tr>
<tr class="separator:gaa3d7a7e06600872fb96e40ef31d2af90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46441020dc1fab7e5d4d426b67a8885"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#gae46441020dc1fab7e5d4d426b67a8885">glmesh::gen::Icosahedron</a> (const ColorArray &amp;colorSequence=ColorArray())</td></tr>
<tr class="memdesc:gae46441020dc1fab7e5d4d426b67a8885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a regular, unit icosahedron.  <a href="#gae46441020dc1fab7e5d4d426b67a8885">More...</a><br/></td></tr>
<tr class="separator:gae46441020dc1fab7e5d4d426b67a8885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Quadric Surfaces</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2ec00374f8a70930176d9a6b9c925a20"></a><a href="http://en.wikipedia.org/wiki/Quadric">Quadric Surfaces</a> are curved surfaces defined by multi-dimensional quadratic equations. It is a special class of surface that includes cones, cylinders, and spheres. These functions generate unit meshes for these shapes. </p>
</td></tr>
<tr class="memitem:ga3d6d8897f258484fa8c069ce245ea088"><td class="memItemLeft" align="right" valign="top">Mesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__module__glmesh__mesh__generator.html#ga3d6d8897f258484fa8c069ce245ea088">glmesh::gen::UnitSphere</a> (int numHorizSlices, int numVertSlices)</td></tr>
<tr class="memdesc:ga3d6d8897f258484fa8c069ce245ea088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit sphere at the origin.  <a href="#ga3d6d8897f258484fa8c069ce245ea088">More...</a><br/></td></tr>
<tr class="separator:ga3d6d8897f258484fa8c069ce245ea088"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5513a56bfc83bca63125e933227cfcd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::Cube </td>
          <td>(</td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a unit cube. </p>
<p>A cube is... OK, do you really need me to tell you what a <em>cube</em> is?</p>
<p>The cube is on the range [-1, 1], so the lengths of its sides are 2. The cube is axis-aligned.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument.</li>
</ul>
<p>The order of the colors is such that, if you pass a 3 element list, then each pair of faces on opposite sides of the cube will have the same color. The order of colors is: +Y, +X, +Z, -Y, -X, -Z. </p>

</div>
</div>
<a class="anchor" id="gab0e2e9c342f7d20f172746488b492fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::CubeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCubesOnEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a cubical block of cubes in an alternating pattern. </p>
<p>Each cube is a cube of size 2. The entire array will be centered around it's centerpoint. The array's length on one side will be <code>2 * (2n - 1)</code>, where <code>n</code> is the number of cubes on an edge.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCubesOnEdge</td><td>The number of cubes that will appear on each edge. Will be clamped to the range [1, 16384]. </td></tr>
    <tr><td class="paramname">colorSequence</td><td>A series of colors used to color the faces of the objects. The order of faces is: +y, +x, -y, -x, +z, -z. The color used will wrap around, so if you provide 6 colors, then each cube will get the same six colors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08e3ef4891fa22062886d18c22ac1489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::CubePyramid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCubesTall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pyramid made of cubes, in an alternating pattern. </p>
<p>Each cube is a cube of size 2. The pyramid will be pointing in the positive y axis. The entire array will be centered around its X/Z centerpoint, with the zero y at the base of the pyramid. The height will be <code>2*n</code>, where <code>n</code> is the number of cubes in height. The width/depth will be <code>2 * (2n - 1)</code>.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCubesTall</td><td>How many cubes in height the pyramid will be. Will be clamped to the range [1, 16383]. </td></tr>
    <tr><td class="paramname">colorSequence</td><td>A series of colors used to color the faces of the objects. The order of faces is: +y, +x, -y, -x, +z, -z. The color used will wrap around, so if you provide 6 colors, then each cube will get the same six colors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3d7a7e06600872fb96e40ef31d2af90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::Dodecahedron </td>
          <td>(</td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a regular, (nearly) unit dodecahedron. </p>
<p>A dodecahedron is a 12-sided solid, where each face is a pentagon. It is regular in that the pentagonal faces are all equilateral.</p>
<p>The dodecahedron is oriented so that two opposite faces face directly in the +Y and -Y axes.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument.</li>
</ul>
<p>Note that the color here represents the color per <em>face</em>, not just per triangle used to build that face. So each of the triangles in a pentagon gets the same color. The order of the colors is such that, if you provide 6 colors, then the opposite faces will all have the same color.</p>
<p>The first color is for the top face (+Y). The next 5 are for the faces that point in the +Y axis, starting from the one facing directly +X (with no Z in its facing). These proceed clockwise, as seen when looking down at the dodecahedron. The other 6 faces are the opposing faces for those faces. </p>

</div>
</div>
<a class="anchor" id="ga2930a467ffc520ce9e4e82e8fcc9712e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::FullScreenQuad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mesh of a full-screen quad. Useful for post-processing effects. </p>
<p>This is a quad that covers the screen. Your vertex shader should pass the positions without transformation. The positions are already in clip-space.</p>
<p>This mesh has only the position attribute. The position's Z is always 0, and the W is 1. </p>

</div>
</div>
<a class="anchor" id="gaf99cf6f0f84aba3c82900c5f20efc1b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::GroundPlane </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numXVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numYVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDoubleSided</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mesh ground plane. Can be double-sided and arbitrarily tessellated. </p>
<p>This creates a square, on the range [-1, 1] in the XY plane (faces in the +Z direction). The quad can be tessellated arbitrarily, via parameters.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>texture coordinates: The lower-left corner of the texture is in the -X/-Y part of the square.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numXVerts</td><td>Number of vertices along the X axis. Must be 2 or greater. </td></tr>
    <tr><td class="paramname">numYVerts</td><td>Number of vertices along the Y axis. Must be 2 or greater. </td></tr>
    <tr><td class="paramname">bDoubleSided</td><td>Whether the ground is double-sided or not. If not, then CCW will point in the positive-Y. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae46441020dc1fab7e5d4d426b67a8885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::Icosahedron </td>
          <td>(</td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a regular, unit icosahedron. </p>
<p>An icosahedron is a 20-sided, triangular solid. It is regular in that all of the triangles used in creating it are equilateral.</p>
<p>The icosahedron is oriented so that two opposite vertices are in the +Y and -Y axes.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2347c82475d03c07a3ff286f1ce22bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::Octahedron </td>
          <td>(</td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a regular, unit octahedron. </p>
<p>An octahedron is an 8-sided, triangular solid. It is regular in that all of the triangles used in creating it are equilateral.</p>
<p>The octahedron's 6 vertices point in the axial directions. All of the points lie in [-1, 1], and the 6 positions are all right on the border.</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2a1ee94134474b911c2939d6840c1c3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::Tetrahedron </td>
          <td>(</td>
          <td class="paramtype">const ColorArray &amp;&#160;</td>
          <td class="paramname"><em>colorSequence</em> = <code>ColorArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a regular, unit tetrahedron. </p>
<p>A tetrahedron is a 4-sided, triangular solid. It is regular in the sense that all of the triangles used to construct it are equilateral.</p>
<p>The tetrahedron is generated with one vertex pointed in the +Y direction, with the flat size directly facing the -Y direction. It is a regular tetrahedron, so all of the triangles are equilateral. The geometric center of the tetrahedron is at the origin. The points of the tetrahedron are within the [-1, 1] range of the origin.</p>
<p>The top point of the tetrahedron is exactly at (0, 1, 0).</p>
<p>Available attributes: </p>
<ul>
<li>normals </li>
<li>color, if you pass a non-empty <em>colorSequence</em> argument. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga3d6d8897f258484fa8c069ce245ea088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh* glmesh::gen::UnitSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numHorizSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVertSlices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unit sphere at the origin. </p>
<p>A unit sphere is a sphere of radius 1, so it extends from [-1, 1] in all three axes.</p>
<p>Available attributes:</p>
<ul>
<li>normal </li>
<li>texture coordinate: It has a degeneracy at the top and bottom.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numHorizSlices</td><td>The number of horizontal slices of the sphere. More slices make it smoother. </td></tr>
    <tr><td class="paramname">numVertSlices</td><td>The number of vertical slices of the sphere. More slices make it smoother. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 29 2013 05:35:00 for Unofficial OpenGL Software Development Kit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
