<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Unofficial OpenGL Software Development Kit: glutil::MatrixStack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unofficial OpenGL Software Development Kit
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceglutil.html">glutil</a></li><li class="navelem"><a class="el" href="classglutil_1_1_matrix_stack.html">MatrixStack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classglutil_1_1_matrix_stack-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">glutil::MatrixStack Class Reference<div class="ingroups"><a class="el" href="group__module__glutil__matrixstack.html">Matrix Stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_matrix_stack_8h_source.html">MatrixStack.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="textblock"><p>Implements a stack for glm::mat4 transformations. </p>
<p>A matrix stack is a sequence of transforms which you can preserve and restore as needed. The stack has the concept of a "current matrix", which can be retrieved with the <a class="el" href="classglutil_1_1_matrix_stack.html#a2774dd8b4f66914d783a3f285f7a6886" title="Retrieve the current matrix.">Top()</a> function. The top matrix can even be obtained as a float array. The pointer returned will remain valid until this object is destroyed (though its values will change when you modify the current matrix). This is useful for uploading matrices to OpenGL via <a href="http://www.opengl.org/wiki/GLAPI/glUniform">`glUniformMatrix4fv`</a>.</p>
<p>The other functions will right-multiply a transformation matrix with the current matrix, thus changing the current matrix.</p>
<p>The main power of the matrix stack is the ability to preserve and restore matrices in a stack fashion. The current matrix can be preserved on the stack with <a class="el" href="classglutil_1_1_matrix_stack.html#a9f4ba2c55104a7ddcb01ace0307c59cd" title="Preserves the current matrix on the stack.">Push()</a> and the most recently preserved matrix can be restored with <a class="el" href="classglutil_1_1_matrix_stack.html#a513e6aa14c44b6463cf2f626a71b651c" title="Restores the most recently preserved matrix.">Pop()</a>. You must ensure that you do not <a class="el" href="classglutil_1_1_matrix_stack.html#a513e6aa14c44b6463cf2f626a71b651c" title="Restores the most recently preserved matrix.">Pop()</a> more times than you <a class="el" href="classglutil_1_1_matrix_stack.html#a9f4ba2c55104a7ddcb01ace0307c59cd" title="Preserves the current matrix on the stack.">Push()</a>. Also, while this matrix stack does not have an explicit size limit, if you <a class="el" href="classglutil_1_1_matrix_stack.html#a9f4ba2c55104a7ddcb01ace0307c59cd" title="Preserves the current matrix on the stack.">Push()</a> more times than you <a class="el" href="classglutil_1_1_matrix_stack.html#a513e6aa14c44b6463cf2f626a71b651c" title="Restores the most recently preserved matrix.">Pop()</a>, then you can eventually run out of memory (unless you create and destroy the <a class="el" href="classglutil_1_1_matrix_stack.html" title="Implements a stack for glm::mat4 transformations.">MatrixStack</a> every frame).</p>
<p>The best way to manage the stack is to never use the <a class="el" href="classglutil_1_1_matrix_stack.html#a9f4ba2c55104a7ddcb01ace0307c59cd" title="Preserves the current matrix on the stack.">Push()</a> and <a class="el" href="classglutil_1_1_matrix_stack.html#a513e6aa14c44b6463cf2f626a71b651c" title="Restores the most recently preserved matrix.">Pop()</a> methods directly. Instead, use the <a class="el" href="classglutil_1_1_push_stack.html" title="RAII-style object for pushing/popping MatrixStack objects.">PushStack</a> object to do all pushing and popping. That will ensure that overflows and underflows cannot not happen. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3599ac053b9708b1f046a2d8f0fb5a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3599ac053b9708b1f046a2d8f0fb5a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#af3599ac053b9708b1f046a2d8f0fb5a6">MatrixStack</a> ()</td></tr>
<tr class="memdesc:af3599ac053b9708b1f046a2d8f0fb5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the matrix stack with the identity matrix. <br/></td></tr>
<tr class="separator:af3599ac053b9708b1f046a2d8f0fb5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7a3e2fc8e29e004c73f0380118e45f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b7a3e2fc8e29e004c73f0380118e45f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a4b7a3e2fc8e29e004c73f0380118e45f">MatrixStack</a> (const glm::mat4 &amp;initialMatrix)</td></tr>
<tr class="memdesc:a4b7a3e2fc8e29e004c73f0380118e45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the matrix stack with the given matrix. <br/></td></tr>
<tr class="separator:a4b7a3e2fc8e29e004c73f0380118e45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stack Maintanence Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions maintain the matrix stack. You must take care not to underflow or overflow the stack. </p>
</div></td></tr>
<tr class="memitem:a9f4ba2c55104a7ddcb01ace0307c59cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f4ba2c55104a7ddcb01ace0307c59cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a9f4ba2c55104a7ddcb01ace0307c59cd">Push</a> ()</td></tr>
<tr class="memdesc:a9f4ba2c55104a7ddcb01ace0307c59cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preserves the current matrix on the stack. <br/></td></tr>
<tr class="separator:a9f4ba2c55104a7ddcb01ace0307c59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e6aa14c44b6463cf2f626a71b651c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513e6aa14c44b6463cf2f626a71b651c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a513e6aa14c44b6463cf2f626a71b651c">Pop</a> ()</td></tr>
<tr class="memdesc:a513e6aa14c44b6463cf2f626a71b651c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the most recently preserved matrix. <br/></td></tr>
<tr class="separator:a513e6aa14c44b6463cf2f626a71b651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd48205ef03571fda9a0a2541a6c2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a5fd48205ef03571fda9a0a2541a6c2c8">Reset</a> ()</td></tr>
<tr class="memdesc:a5fd48205ef03571fda9a0a2541a6c2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the current matrix to the value of the most recently preserved matrix.  <a href="#a5fd48205ef03571fda9a0a2541a6c2c8">More...</a><br/></td></tr>
<tr class="separator:a5fd48205ef03571fda9a0a2541a6c2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2774dd8b4f66914d783a3f285f7a6886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2774dd8b4f66914d783a3f285f7a6886"></a>
const glm::mat4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a2774dd8b4f66914d783a3f285f7a6886">Top</a> () const </td></tr>
<tr class="memdesc:a2774dd8b4f66914d783a3f285f7a6886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current matrix. <br/></td></tr>
<tr class="separator:a2774dd8b4f66914d783a3f285f7a6886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rotation Matrix Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply the current matrix with a rotation matrix of some form. All rotation angles are counter-clockwise for an observer looking down the axis direction. If an observer is facing so that the axis of rotation is pointing directly towards the user, then positive angles will rotate counter-clockwise. </p>
</div></td></tr>
<tr class="memitem:aabf06f07b9e54d61959496e5ec6a6b82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf06f07b9e54d61959496e5ec6a6b82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#aabf06f07b9e54d61959496e5ec6a6b82">Rotate</a> (const glm::vec3 axis, float angDegCCW)</td></tr>
<tr class="memdesc:aabf06f07b9e54d61959496e5ec6a6b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a rotation matrix about the given axis, with the given angle in degrees. <br/></td></tr>
<tr class="separator:aabf06f07b9e54d61959496e5ec6a6b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc0b534c9bcc0204a2660d59faaed32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc0b534c9bcc0204a2660d59faaed32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a2dc0b534c9bcc0204a2660d59faaed32">RotateRadians</a> (const glm::vec3 axis, float angRadCCW)</td></tr>
<tr class="memdesc:a2dc0b534c9bcc0204a2660d59faaed32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a rotation matrix about the given axis, with the given angle in radians. <br/></td></tr>
<tr class="separator:a2dc0b534c9bcc0204a2660d59faaed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7d7f344a5343c62ce5223747c71fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7d7f344a5343c62ce5223747c71fdb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#acf7d7f344a5343c62ce5223747c71fdb">RotateX</a> (float angDegCCW)</td></tr>
<tr class="memdesc:acf7d7f344a5343c62ce5223747c71fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a rotation matrix about the +X axis, with the given angle in degrees. <br/></td></tr>
<tr class="separator:acf7d7f344a5343c62ce5223747c71fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7334a931b280a7022052f7daf58d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed7334a931b280a7022052f7daf58d81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#aed7334a931b280a7022052f7daf58d81">RotateY</a> (float angDegCCW)</td></tr>
<tr class="memdesc:aed7334a931b280a7022052f7daf58d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a rotation matrix about the +Y axis, with the given angle in degrees. <br/></td></tr>
<tr class="separator:aed7334a931b280a7022052f7daf58d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa0ddae1991abcda5fa3987b9187765"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aa0ddae1991abcda5fa3987b9187765"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a1aa0ddae1991abcda5fa3987b9187765">RotateZ</a> (float angDegCCW)</td></tr>
<tr class="memdesc:a1aa0ddae1991abcda5fa3987b9187765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a rotation matrix about the +Z axis, with the given angle in degrees. <br/></td></tr>
<tr class="separator:a1aa0ddae1991abcda5fa3987b9187765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scale Matrix Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply the current matrix with a scaling matrix of some form. </p>
</div></td></tr>
<tr class="memitem:a8a79d249c1b93c7687633eb1514fa903"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a79d249c1b93c7687633eb1514fa903"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a8a79d249c1b93c7687633eb1514fa903">Scale</a> (const glm::vec3 &amp;scaleVec)</td></tr>
<tr class="memdesc:a8a79d249c1b93c7687633eb1514fa903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a scale matrix, with the given glm::vec3 as the axis scales. <br/></td></tr>
<tr class="separator:a8a79d249c1b93c7687633eb1514fa903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d60a81bef693d49de303624cdeb8615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d60a81bef693d49de303624cdeb8615"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a7d60a81bef693d49de303624cdeb8615">Scale</a> (float scaleX, float scaleY, float scaleZ)</td></tr>
<tr class="memdesc:a7d60a81bef693d49de303624cdeb8615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a scale matrix, with the given values as the axis scales. <br/></td></tr>
<tr class="separator:a7d60a81bef693d49de303624cdeb8615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53018b5117c9d088c2f60a6392ead0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e53018b5117c9d088c2f60a6392ead0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a1e53018b5117c9d088c2f60a6392ead0">Scale</a> (float uniformScale)</td></tr>
<tr class="memdesc:a1e53018b5117c9d088c2f60a6392ead0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a uniform scale matrix. <br/></td></tr>
<tr class="separator:a1e53018b5117c9d088c2f60a6392ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Translation Matrix Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply the current matrix with a translation matrix of some form. </p>
</div></td></tr>
<tr class="memitem:a84007ff370e2a60985567bc3a619052b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84007ff370e2a60985567bc3a619052b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a84007ff370e2a60985567bc3a619052b">Translate</a> (const glm::vec3 &amp;offsetVec)</td></tr>
<tr class="memdesc:a84007ff370e2a60985567bc3a619052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a translation matrix, with the given glm::vec3 as the offset. <br/></td></tr>
<tr class="separator:a84007ff370e2a60985567bc3a619052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fcb0c377bea8bdcbc7836c2d4d6392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84fcb0c377bea8bdcbc7836c2d4d6392"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a84fcb0c377bea8bdcbc7836c2d4d6392">Translate</a> (float transX, float transY, float transZ)</td></tr>
<tr class="memdesc:a84fcb0c377bea8bdcbc7836c2d4d6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a translation matrix, with the given X, Y and Z values as the offset. <br/></td></tr>
<tr class="separator:a84fcb0c377bea8bdcbc7836c2d4d6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Camera Matrix Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply the current matrix with a matrix that transforms from a world space to the camera space expected by the <a class="el" href="classglutil_1_1_matrix_stack.html#a31a69c1d9b97ea932d2718b9d41384ad" title="Applies a standard, OpenGL-style perspective projection matrix.">Perspective()</a> or <a class="el" href="classglutil_1_1_matrix_stack.html#ac989bb8ca6ebc4b209d4f8432c9fdaf1" title="Applies a standard, OpenGL-style orthographic projection matrix.">Orthographic()</a> functions. </p>
</div></td></tr>
<tr class="memitem:a3c27d04c02b2b11dc396e751470bf8c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a3c27d04c02b2b11dc396e751470bf8c7">LookAt</a> (const glm::vec3 &amp;cameraPos, const glm::vec3 &amp;lookatPos, const glm::vec3 &amp;upDir)</td></tr>
<tr class="memdesc:a3c27d04c02b2b11dc396e751470bf8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a matrix that transforms to a camera-space defined by a position, a target in the world, and an up direction.  <a href="#a3c27d04c02b2b11dc396e751470bf8c7">More...</a><br/></td></tr>
<tr class="separator:a3c27d04c02b2b11dc396e751470bf8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Projection Matrix Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply the current matrix with a projection matrix of some form. These functions all transform positions into the 4D homogeneous space expected by the output of OpenGL vertex shaders. As such, these can be used directly with GLSL shaders.</p>
<p>The space that these matrices transform from is defined as follows. The pre-projection space, called camera space or eye space, has the camera/eye position at the origin. The camera faces down the -Z axis, so objects with larger negative Z values are farther away. +Y is up and +X is to the right. </p>
</div></td></tr>
<tr class="memitem:a31a69c1d9b97ea932d2718b9d41384ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a31a69c1d9b97ea932d2718b9d41384ad">Perspective</a> (float degFOV, float aspectRatio, float zNear, float zFar)</td></tr>
<tr class="memdesc:a31a69c1d9b97ea932d2718b9d41384ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a standard, OpenGL-style perspective projection matrix.  <a href="#a31a69c1d9b97ea932d2718b9d41384ad">More...</a><br/></td></tr>
<tr class="separator:a31a69c1d9b97ea932d2718b9d41384ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989bb8ca6ebc4b209d4f8432c9fdaf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#ac989bb8ca6ebc4b209d4f8432c9fdaf1">Orthographic</a> (float left, float right, float bottom, float top, float zNear=-1.0f, float zFar=1.0f)</td></tr>
<tr class="memdesc:ac989bb8ca6ebc4b209d4f8432c9fdaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a standard, OpenGL-style orthographic projection matrix.  <a href="#ac989bb8ca6ebc4b209d4f8432c9fdaf1">More...</a><br/></td></tr>
<tr class="separator:ac989bb8ca6ebc4b209d4f8432c9fdaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167dbaf3f2208bb638e1581d000a64af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a167dbaf3f2208bb638e1581d000a64af">PixelPerfectOrtho</a> (glm::ivec2 size, glm::vec2 depthRange, bool isTopLeft=true)</td></tr>
<tr class="memdesc:a167dbaf3f2208bb638e1581d000a64af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an ortho matrix for pixel-accurate reproduction.  <a href="#a167dbaf3f2208bb638e1581d000a64af">More...</a><br/></td></tr>
<tr class="separator:a167dbaf3f2208bb638e1581d000a64af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Application</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions right-multiply a user-provided matrix by the current matrix; the result becomes the new current matrix. </p>
</div></td></tr>
<tr class="memitem:a27e14a86ec43f3422815d19308beb2c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27e14a86ec43f3422815d19308beb2c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a27e14a86ec43f3422815d19308beb2c3">ApplyMatrix</a> (const glm::mat4 &amp;theMatrix)</td></tr>
<tr class="memdesc:a27e14a86ec43f3422815d19308beb2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-multiplies the current matrix with the given one, making the result new current matrix. <br/></td></tr>
<tr class="separator:a27e14a86ec43f3422815d19308beb2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e7b99ea79f13698c008ac8f6c11d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e7b99ea79f13698c008ac8f6c11d10"></a>
<a class="el" href="classglutil_1_1_matrix_stack.html">MatrixStack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a63e7b99ea79f13698c008ac8f6c11d10">operator*=</a> (const glm::mat4 &amp;theMatrix)</td></tr>
<tr class="memdesc:a63e7b99ea79f13698c008ac8f6c11d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-multiplies the current matrix with the given one, making the result new current matrix. <br/></td></tr>
<tr class="separator:a63e7b99ea79f13698c008ac8f6c11d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Setting</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions directly set the value of the current matrix, replacing the old value. Previously preserved matrices on the stack are unaffected. </p>
</div></td></tr>
<tr class="memitem:a621be0676ada936a1f83dc0f70e3d86a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a621be0676ada936a1f83dc0f70e3d86a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a621be0676ada936a1f83dc0f70e3d86a">SetMatrix</a> (const glm::mat4 &amp;theMatrix)</td></tr>
<tr class="memdesc:a621be0676ada936a1f83dc0f70e3d86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given matrix becomes the current matrix. <br/></td></tr>
<tr class="separator:a621be0676ada936a1f83dc0f70e3d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bde8083a8881ecf306d5b7d535a22fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bde8083a8881ecf306d5b7d535a22fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglutil_1_1_matrix_stack.html#a8bde8083a8881ecf306d5b7d535a22fe">SetIdentity</a> ()</td></tr>
<tr class="memdesc:a8bde8083a8881ecf306d5b7d535a22fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current matrix to the identity matrix. <br/></td></tr>
<tr class="separator:a8bde8083a8881ecf306d5b7d535a22fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3c27d04c02b2b11dc396e751470bf8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glutil::MatrixStack::LookAt </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>cameraPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>lookatPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>upDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a matrix that transforms to a camera-space defined by a position, a target in the world, and an up direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraPos</td><td>The world-space position of the camera. </td></tr>
    <tr><td class="paramname">lookatPos</td><td>The world-space position the camera should be facing. It should not be equal to <em>cameraPos</em>. </td></tr>
    <tr><td class="paramname">upDir</td><td>The world-space direction vector that should be considered up. The generated matrix will be bad if the up direction is along the same direction as the direction the camera faces (the direction between <em>cameraPos</em> and <em>lookatPos</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac989bb8ca6ebc4b209d4f8432c9fdaf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glutil::MatrixStack::Orthographic </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em> = <code>-1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a standard, OpenGL-style orthographic projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left camera-space position in the X axis that will be captured within the projection. </td></tr>
    <tr><td class="paramname">right</td><td>The right camera-space position in the X axis that will be captured within the projection. </td></tr>
    <tr><td class="paramname">bottom</td><td>The bottom camera-space position in the Y axis that will be captured within the projection. </td></tr>
    <tr><td class="paramname">top</td><td>The top camera-space position in the Y axis that will be captured within the projection. </td></tr>
    <tr><td class="paramname">zNear</td><td>The front camera-space position in the Z axis that will be captured within the projection. </td></tr>
    <tr><td class="paramname">zFar</td><td>The rear camera-space position in the Z axis that will be captured within the projection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31a69c1d9b97ea932d2718b9d41384ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glutil::MatrixStack::Perspective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degFOV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a standard, OpenGL-style perspective projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degFOV</td><td>The field of view. This is the angle in degrees between directly forward and the farthest visible point horizontally. </td></tr>
    <tr><td class="paramname">aspectRatio</td><td>The ratio of the width of the view area to the height. </td></tr>
    <tr><td class="paramname">zNear</td><td>The closest camera-space distance to the camera that can be seen. The projection will be clipped against this value. It cannot be negative or 0.0. </td></tr>
    <tr><td class="paramname">zFar</td><td>The farthest camera-space distance from the camera that can be seen. The projection will be clipped against this value. It must be larger than <em>zNear</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a167dbaf3f2208bb638e1581d000a64af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glutil::MatrixStack::PixelPerfectOrtho </td>
          <td>(</td>
          <td class="paramtype">glm::ivec2&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>depthRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTopLeft</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies an ortho matrix for pixel-accurate reproduction. </p>
<p>A common use for orthographic projections is to create an ortho matrix that allows for pixel-accurate reproduction of textures. It allows you to provide vertices directly in window space.</p>
<p>The camera space that this function creates can have the origin at the top-left (with +y going down) or bottom-left (with +y going up). Note that a top-left orientation will have to flip the Y coordinate, which means that the winding order of any triangles are reversed.</p>
<p>The depth range is arbitrary and up to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the window space. </td></tr>
    <tr><td class="paramname">depthRange</td><td>The near and far depth range. The x coord is zNear, and the y coord is zFar. </td></tr>
    <tr><td class="paramname">isTopLeft</td><td>True if this should be top-left orientation, false if it should be bottom-left. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fd48205ef03571fda9a0a2541a6c2c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void glutil::MatrixStack::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores the current matrix to the value of the most recently preserved matrix. </p>
<p>This function does not affect the depth of the matrix stack. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Projects/distro/glsdk_0_5_1/glutil/include/glutil/<a class="el" href="_matrix_stack_8h_source.html">MatrixStack.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 29 2013 05:35:01 for Unofficial OpenGL Software Development Kit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
