<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <meta http-equiv="X-UA-Compatible" content="IE=Edge"><title>In Review</title><link rel="stylesheet" href="chunked.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="../index.html" title="Learning Modern 3D Graphics Programming"><link rel="up" href="Tutorial 09.html" title="Chapter&nbsp;9.&nbsp;Lights On"><link rel="prev" href="Tut09 Mesh Topology.html" title="Mesh Topology"><link rel="next" href="Tut09 Glossary.html" title="Glossary"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">In Review</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="Tut09 Mesh Topology.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;9.&nbsp;Lights On</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="Tut09 Glossary.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9593"></a>In Review</h2></div></div></div><p>In this tutorial, you have learned the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Diffuse lighting is a simple lighting model based on the angle between the
                    light source and the surface normal.</p></li><li class="listitem"><p>Surface normals are values used, per-vertex, to define the direction of the
                    surface at a particular location. They do not have to mirror the actual normal
                    of the mesh geometry.</p></li><li class="listitem"><p>Surface normals must be transformed by the inverse-transpose of the
                    model-to-camera matrix, if that matrix can involve a non-uniform scale
                    operation.</p></li><li class="listitem"><p>Light interreflection can be approximated by adding a single light intensity
                    that has no direction.</p></li><li class="listitem"><p>Each vertex attribute has its own topology. In order to render these vertices
                    in OpenGL, attribute data must be replicated so that each unique combination of
                    attributes has a topology.</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9615"></a>Further Study</h3></div></div></div><p>Try doing these things with the given programs.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Modify the ambient lighting tutorial, bumping the diffuse light intensity
                        up to 1.0. See how this effects the results.</p></li><li class="listitem"><p>Change the shaders in the ambient lighting tutorial to use the lighting
                        intensity correction mentioned above. Divide the diffuse color by a value,
                        then pass larger lighting intensities to the shader. Notice how this changes
                        the quality of the lighting.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9627"></a>Further Research</h3></div></div></div><p>Lambertian diffuse reflectance is a rather good model for diffuse reflectance for
                many surfaces. Particularly rough surfaces however do not behave in a Lambertian
                manor. If you are interested in modelling such surfaces, investigate the Oren-Nayar
                reflectance model.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9632"></a>GLSL Functions of Note</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">vec <b class="fsfunc">clamp</b>(</code></td><td>vec <var class="pdparam">val</var>, </td></tr><tr><td>&nbsp;</td><td>vec <var class="pdparam">minVal</var>, </td></tr><tr><td>&nbsp;</td><td>vec <var class="pdparam">maxVal</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function does a clamping operation of each component of
                    <em class="parameter"><code>val</code></em>. All of the parameters must scalars or vectors of the
                same dimensionality. This function will work with any scalar or vector type. It
                returns a scalar or vector of the same dimensionality as the parameters, where each
                component of <em class="parameter"><code>val</code></em> will be clamped to the closed range
                    [<em class="parameter"><code>minVal</code></em>, <em class="parameter"><code>maxVal</code></em>]. This is useful
                for ensuring that values are in a certain range.</p><p>All components of <em class="parameter"><code>minVal</code></em>
                <span class="emphasis"><em>must</em></span> be smaller than the corresponding components of
                    <em class="parameter"><code>maxVal</code></em>.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">float <b class="fsfunc">dot</b>(</code></td><td>vec <var class="pdparam">x</var>, </td></tr><tr><td>&nbsp;</td><td>vec <var class="pdparam">y</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function performs a vector dot product on <em class="parameter"><code>x</code></em> and
                    <em class="parameter"><code>y</code></em>. This always results in a scalar value. The two
                parameters must have the same dimensionality and must be vectors.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">vec <b class="fsfunc">normalize</b>(</code></td><td>vec <var class="pdparam">x</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function returns a vector in the same direction as <em class="parameter"><code>x</code></em>,
                but with a length of 1. <em class="parameter"><code>x</code></em> must have a length greater than 0
                (that is, it cannot be a vector with all zeros).</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Tut09 Mesh Topology.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="Tutorial 09.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="Tut09 Glossary.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Mesh Topology&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Glossary</td></tr></table></div></body></html>